"""
Generate a lookup table for coast phase altitude gain.
Creates a 2D matrix of remaining altitude based on initial velocity and Cd.
"""
import numpy as np

# Constants from config.h
MASS = 0.603  # kg
AREA = (np.pi * (6.6 / 100.0) ** 2) / 4.0  # m^2
RHO = 1.225  # kg/m^3
G = 9.80665  # m/s^2

# Simulation parameters
DT = 0.001  # 1 kHz for accuracy

def simulate_coast(initial_velocity, cd):
    """
    Simulate coast phase starting from given velocity and Cd.
    Returns the altitude gained until apogee.
    """
    vel = initial_velocity
    alt_gained = 0.0
    t = 0.0
    
    # Coast until velocity becomes non-positive
    while vel > 0 and t < 20.0:  # Safety timeout
        # Drag force
        drag = -0.5 * RHO * AREA * cd * vel * abs(vel)
        weight = -MASS * G
        
        # Acceleration
        accel = (drag + weight) / MASS
        
        # Simple Euler integration (fast and good enough for lookup table)
        vel += accel * DT
        alt_gained += vel * DT
        t += DT
    
    return max(0.0, alt_gained)  # Ensure non-negative


def generate_coast_table(n_vel=16, n_cd=16):
    """
    Generate coast phase lookup table.
    
    Args:
        n_vel: Number of velocity samples
        n_cd: Number of Cd samples
    
    Returns:
        vel_range: Array of velocity values
        cd_range: Array of Cd values
        altitude_table: 2D array [n_vel, n_cd] of altitude gains
    """
    # Define ranges based on expected flight conditions
    vel_min, vel_max = 0.0, 80.0  # m/s
    cd_min, cd_max = 0.44, 4.0
    
    vel_range = np.linspace(vel_min, vel_max, n_vel)
    cd_range = np.linspace(cd_min, cd_max, n_cd)
    
    altitude_table = np.zeros((n_vel, n_cd))
    
    print(f"Generating {n_vel}x{n_cd} coast phase lookup table...")
    print(f"Velocity range: {vel_min:.1f} - {vel_max:.1f} m/s")
    print(f"Cd range: {cd_min:.2f} - {cd_max:.2f}")
    
    for i, vel in enumerate(vel_range):
        for j, cd in enumerate(cd_range):
            altitude_table[i, j] = simulate_coast(vel, cd)
        
        if (i + 1) % 4 == 0:
            print(f"Progress: {i+1}/{n_vel} velocity samples completed")
    
    print("Table generation complete!")
    print(f"Altitude range: {np.min(altitude_table):.2f} - {np.max(altitude_table):.2f} m")
    
    return vel_range, cd_range, altitude_table


def save_coast_table_to_file(vel_range, cd_range, altitude_table, filename='coast_table.py'):
    """Save the coast table as a Python module."""
    with open(filename, 'w') as f:
        f.write('"""\n')
        f.write('Coast phase lookup table for apogee prediction.\n')
        f.write('Auto-generated by generate_coast_table.py\n')
        f.write('"""\n')
        f.write('import numpy as np\n\n')
        
        f.write('# Velocity range (m/s)\n')
        f.write(f'VEL_RANGE = np.array({vel_range.tolist()})\n\n')
        
        f.write('# Cd range\n')
        f.write(f'CD_RANGE = np.array({cd_range.tolist()})\n\n')
        
        f.write('# Altitude gain table [n_vel, n_cd] (meters)\n')
        f.write('ALTITUDE_TABLE = np.array([\n')
        for row in altitude_table:
            f.write('    ' + str(row.tolist()) + ',\n')
        f.write('])\n\n')
        
        f.write('def get_remaining_altitude(velocity, cd):\n')
        f.write('    """\n')
        f.write('    Get remaining altitude to apogee using bilinear interpolation.\n')
        f.write('    \n')
        f.write('    Args:\n')
        f.write('        velocity: Current velocity (m/s)\n')
        f.write('        cd: Current drag coefficient\n')
        f.write('    \n')
        f.write('    Returns:\n')
        f.write('        Estimated remaining altitude (m)\n')
        f.write('    """\n')
        f.write('    # Clamp inputs to table bounds\n')
        f.write('    vel = np.clip(velocity, VEL_RANGE[0], VEL_RANGE[-1])\n')
        f.write('    cd_val = np.clip(cd, CD_RANGE[0], CD_RANGE[-1])\n')
        f.write('    \n')
        f.write('    # Find indices for bilinear interpolation\n')
        f.write('    vel_idx = np.searchsorted(VEL_RANGE, vel) - 1\n')
        f.write('    vel_idx = np.clip(vel_idx, 0, len(VEL_RANGE) - 2)\n')
        f.write('    \n')
        f.write('    cd_idx = np.searchsorted(CD_RANGE, cd_val) - 1\n')
        f.write('    cd_idx = np.clip(cd_idx, 0, len(CD_RANGE) - 2)\n')
        f.write('    \n')
        f.write('    # Get corner values\n')
        f.write('    v0, v1 = VEL_RANGE[vel_idx], VEL_RANGE[vel_idx + 1]\n')
        f.write('    c0, c1 = CD_RANGE[cd_idx], CD_RANGE[cd_idx + 1]\n')
        f.write('    \n')
        f.write('    # Bilinear interpolation weights\n')
        f.write('    vel_weight = (vel - v0) / (v1 - v0) if v1 != v0 else 0.0\n')
        f.write('    cd_weight = (cd_val - c0) / (c1 - c0) if c1 != c0 else 0.0\n')
        f.write('    \n')
        f.write('    # Get corner altitudes\n')
        f.write('    alt_00 = ALTITUDE_TABLE[vel_idx, cd_idx]\n')
        f.write('    alt_01 = ALTITUDE_TABLE[vel_idx, cd_idx + 1]\n')
        f.write('    alt_10 = ALTITUDE_TABLE[vel_idx + 1, cd_idx]\n')
        f.write('    alt_11 = ALTITUDE_TABLE[vel_idx + 1, cd_idx + 1]\n')
        f.write('    \n')
        f.write('    # Bilinear interpolation\n')
        f.write('    alt_0 = alt_00 * (1 - vel_weight) + alt_10 * vel_weight\n')
        f.write('    alt_1 = alt_01 * (1 - vel_weight) + alt_11 * vel_weight\n')
        f.write('    alt = alt_0 * (1 - cd_weight) + alt_1 * cd_weight\n')
        f.write('    \n')
        f.write('    return alt\n')
    
    print(f"\nCoast table saved to {filename}")


if __name__ == '__main__':
    # Generate the table
    vel_range, cd_range, altitude_table = generate_coast_table(n_vel=16, n_cd=16)
    
    # Save to file
    save_coast_table_to_file(vel_range, cd_range, altitude_table, 'coast_table.py')
    
    print("\\nDone! Import with: from coast_table import get_remaining_altitude")
