"""
Generate a lookup table for coast phase altitude gain.
Creates a 2D matrix of remaining altitude based on initial velocity and Cd.
"""
import numpy as np

# Constants from config.h
MASS = 0.603  # kg
AREA = (np.pi * (6.6 / 100.0) ** 2) / 4.0  # m^2
RHO = 1.225  # kg/m^3
G = 9.80665  # m/s^2

# Simulation parameters
DT = 0.001  # 1 kHz for accuracy

def simulate_coast(initial_velocity, cd):
    """
    Simulate coast phase starting from given velocity and Cd.
    Returns the altitude gained until apogee.
    """
    vel = initial_velocity
    alt_gained = 0.0
    t = 0.0
    
    # Coast until velocity becomes non-positive
    while vel > 0 and t < 20.0:  # Safety timeout
        # Drag force
        drag = -0.5 * RHO * AREA * cd * vel * abs(vel)
        weight = -MASS * G
        
        # Acceleration
        accel = (drag + weight) / MASS
        
        # Simple Euler integration (fast and good enough for lookup table)
        vel += accel * DT
        alt_gained += vel * DT
        t += DT
    
    return max(0.0, alt_gained)  # Ensure non-negative


def generate_coast_table(n_vel=16, n_cd=16):
    """
    Generate coast phase lookup table.
    
    Args:
        n_vel: Number of velocity samples
        n_cd: Number of Cd samples
    
    Returns:
        vel_range: Array of velocity values
        cd_range: Array of Cd values
        altitude_table: 2D array [n_vel, n_cd] of altitude gains
    """
    # Define ranges based on expected flight conditions
    vel_min, vel_max = 0.0, 80.0  # m/s
    cd_min, cd_max = 0.0, 5.5
    
    vel_range = np.linspace(vel_min, vel_max, n_vel)
    cd_range = np.linspace(cd_min, cd_max, n_cd)
    
    altitude_table = np.zeros((n_vel, n_cd))
    
    print(f"Generating {n_vel}x{n_cd} coast phase lookup table...")
    print(f"Velocity range: {vel_min:.1f} - {vel_max:.1f} m/s")
    print(f"Cd range: {cd_min:.2f} - {cd_max:.2f}")
    
    for i, vel in enumerate(vel_range):
        for j, cd in enumerate(cd_range):
            altitude_table[i, j] = simulate_coast(vel, cd)
        
        if (i + 1) % 4 == 0:
            print(f"Progress: {i+1}/{n_vel} velocity samples completed")
    
    print("Table generation complete!")
    print(f"Altitude range: {np.min(altitude_table):.2f} - {np.max(altitude_table):.2f} m")
    
    return vel_range, cd_range, altitude_table


def save_coast_table_to_file(vel_range, cd_range, altitude_table, filename='coast_table.py'):
    """Save the coast table as a Python module."""
    with open(filename, 'w') as f:
        f.write('"""\n')
        f.write('Coast phase lookup table for apogee prediction.\n')
        f.write('Auto-generated by generate_coast_table.py\n')
        f.write('"""\n')
        f.write('import numpy as np\n\n')
        
        f.write('# Velocity range (m/s)\n')
        f.write(f'VEL_RANGE = np.array({vel_range.tolist()})\n\n')
        
        f.write('# Cd range\n')
        f.write(f'CD_RANGE = np.array({cd_range.tolist()})\n\n')
        
        f.write('# Altitude gain table [n_vel, n_cd] (meters)\n')
        f.write('ALTITUDE_TABLE = np.array([\n')
        for row in altitude_table:
            f.write('    ' + str(row.tolist()) + ',\n')
        f.write('])\n')
    
    print(f"\nCoast table saved to {filename}")


def save_coast_table_to_cpp(vel_range, cd_range, altitude_table, filename='../include/coast_table.h'):
    """Save the coast table as a C++ header."""
    n_vel = len(vel_range)
    n_cd = len(cd_range)
    with open(filename, 'w') as f:
        f.write('#ifndef COAST_TABLE_H\n')
        f.write('#define COAST_TABLE_H\n\n')
        f.write('// Auto-generated by generate_coast_table.py\n')
        f.write(f'// {n_vel}x{n_cd} table, vel {vel_range[0]:.1f}-{vel_range[-1]:.1f} m/s, Cd {cd_range[0]:.2f}-{cd_range[-1]:.2f}\n\n')
        f.write(f'constexpr int COAST_N_VEL = {n_vel};\n')
        f.write(f'constexpr int COAST_N_CD = {n_cd};\n\n')
        f.write(f'constexpr float COAST_VEL_MIN = {vel_range[0]:.1f}f;\n')
        f.write(f'constexpr float COAST_VEL_MAX = {vel_range[-1]:.1f}f;\n')
        f.write(f'constexpr float COAST_VEL_STEP = {(vel_range[-1] - vel_range[0]) / (n_vel - 1):.10f}f;\n')
        f.write(f'constexpr float COAST_CD_MIN = {cd_range[0]:.2f}f;\n')
        f.write(f'constexpr float COAST_CD_MAX = {cd_range[-1]:.2f}f;\n')
        f.write(f'constexpr float COAST_CD_STEP = {(cd_range[-1] - cd_range[0]) / (n_cd - 1):.10f}f;\n\n')
        f.write('// Altitude gain table [n_vel][n_cd] (meters)\n')
        f.write(f'constexpr float COAST_ALTITUDE_TABLE[{n_vel}][{n_cd}] = {{\n')
        for row in altitude_table:
            vals = ', '.join(f'{v:.6f}f' for v in row)
            f.write(f'    {{{vals}}},\n')
        f.write('};\n\n')
        f.write('#endif  // COAST_TABLE_H\n')
    print(f'Coast table C++ header saved to {filename}')


if __name__ == '__main__':
    # Generate the table
    vel_range, cd_range, altitude_table = generate_coast_table(n_vel=20, n_cd=20)
    
    # Save to Python file
    save_coast_table_to_file(vel_range, cd_range, altitude_table, 'coast_table.py')
    
    # Save to C++ header
    save_coast_table_to_cpp(vel_range, cd_range, altitude_table)
    
    print('\nDone!')
